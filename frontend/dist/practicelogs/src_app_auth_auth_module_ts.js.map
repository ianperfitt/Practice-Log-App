{"version":3,"file":"src_app_auth_auth_module_ts.js","mappings":"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A;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,IAAI;AACN;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;ACpIkC;;AAElC;AACA;AACA;AACA;AACA,wBAAwB,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,YAAY;AAC1H;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,UAAU;AAC/F;AACA;AACA;AACA;AACA,uFAAuF,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,UAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,IAAI;AAC9E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAE0G;;;;;;;;;;;;;;;ACrP1G;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA","sources":["./src/app/auth/auth-routing.module.ts","./src/app/auth/auth.module.ts","./src/app/auth/components/auth-form/auth-form.component.ts","./src/app/auth/components/auth-form/auth-form.component.html","./src/app/auth/page/login/login.component.ts","./src/app/auth/page/login/login.component.html","./src/app/auth/page/register/register.component.ts","./src/app/auth/page/register/register.component.html","./src/app/auth/state/auth.actions.ts","./src/app/auth/state/auth.effects.ts","./src/app/auth/state/auth.reducers.ts","./src/app/auth/state/auth.selectors.ts","./src/app/core/core.module.ts","./node_modules/deepmerge/dist/cjs.js","./node_modules/ngrx-store-localstorage/fesm2015/ngrx-store-localstorage.mjs","./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"],"sourcesContent":["import { NgModule } from '@angular/core';\nimport { LoginComponent } from './page/login/login.component';\nimport { RegisterComponent } from './page/register/register.component';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  {\n    path: \"\",\n    component: LoginComponent\n  },\n  {\n    path: \"register\",\n    component: RegisterComponent\n  }\n];\n\n@NgModule({\n  declarations: [],\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class AuthRoutingModule { }\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { CoreModule } from '../core/core.module';\nimport { MaterialModule } from '../material/material.module';\nimport { AuthFormComponent } from './components/auth-form/auth-form.component';\nimport { LoginComponent } from './page/login/login.component';\nimport { RegisterComponent } from './page/register/register.component';\nimport { AuthRoutingModule } from './auth-routing.module';\nimport { ActionReducer, MetaReducer, StoreModule } from '@ngrx/store';\nimport { localStorageSync } from 'ngrx-store-localstorage';\nimport { AuthEffects } from './state/auth.effects';\nimport { authReducer } from './state/auth.reducers';\nimport { EffectsModule } from '@ngrx/effects';\n\nexport function localStorageSyncReducer(reducer: ActionReducer<any>): ActionReducer<any> {\n  return localStorageSync({keys: ['token']})(reducer);\n}\nconst metaReducers: Array<MetaReducer<any, any>> = [localStorageSyncReducer];\n\n\n@NgModule({\n  declarations: [\n    AuthFormComponent,\n    LoginComponent,\n    RegisterComponent\n  ],\n  imports: [\n    CommonModule,\n    AuthRoutingModule,\n    MaterialModule,\n    FormsModule,\n    ReactiveFormsModule,\n    CoreModule,\n    StoreModule.forFeature('authState', authReducer, {metaReducers}),\n    EffectsModule.forFeature([AuthEffects]),\n  ]\n})\nexport class AuthModule { }\n","import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';\nimport { FormBuilder, FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'app-auth-form',\n  templateUrl: './auth-form.component.html',\n  styleUrls: ['./auth-form.component.scss']\n})\nexport class AuthFormComponent {\n  @Input() error: string = \"\";\n  @Input() title: string = \"Login\";\n  @Output() submitEmitter = new EventEmitter();\n  form: FormGroup;\n\n  constructor(private fb: FormBuilder) {\n    this.form = this.fb.group({\n      email: [''],\n      password: ['']\n    })\n   }\n\n   submit() {\n    this.submitEmitter.emit(this.form.value)\n   }\n}\n","<mat-card>\n    <mat-card-title data-cy=\"auth-title\">{{title}}</mat-card-title>\n    <mat-card-content>\n        <form [formGroup]=\"form\" (ngSubmit)=\"submit()\">\n        <p *ngIf=\"error\" class=\"error\">\n            {{ error }}\n        </p>\n        <p>\n            <mat-form-field>\n            <input type=\"text\" matInput placeholder=\"Username\" formControlName=\"email\" data-cy=\"email\">\n            </mat-form-field>\n        </p>\n\n        <p>\n            <mat-form-field>\n            <input type=\"password\" matInput placeholder=\"Password\" formControlName=\"password\"  data-cy=\"password\">\n            </mat-form-field>\n        </p>\n        \n\n\n        <div class=\"button\">\n            <button type=\"submit\" mat-button data-cy=\"submit-login\">{{title}}</button>\n        </div>\n        <p *ngIf=\"title == 'Login'\" class=\"link\" [routerLink]=\"['register']\" routerLinkActive=\"router-link-active\" >Create account</p>\n        <p *ngIf=\"title == 'Register'\" class=\"link\" [routerLink]=\"['']\" routerLinkActive=\"router-link-active\" >Sign In</p>\n        </form>\n    </mat-card-content>\n</mat-card>","import { Component, OnInit } from '@angular/core';\nimport { MatSnackBar } from '@angular/material/snack-bar';\nimport { Router } from '@angular/router';\nimport { Store } from '@ngrx/store';\nimport { AuthenticateService } from 'src/app/core/services/authenticate.service';\nimport { User } from '../../models/user.interface';\nimport { AuthActions } from '../../state/auth.actions';\nimport { selectError } from '../../state/auth.selectors';\n\n\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.scss']\n})\nexport class LoginComponent{\n  error$ = this.store.select(selectError());\n  \n\n  constructor(private store: Store, private authService: AuthenticateService, private router: Router, private _snackBar: MatSnackBar) {\n    this.checkJWT();\n    this.getError();\n  }\n\n  submit(data: User) {\n    this.store.dispatch({type: AuthActions.LOGIN, payload: data})\n\n  }\n\n  getError() {\n    this.error$.subscribe(data => {\n      if(data) {\n        this._snackBar.open(data.message, \"Error\");\n      }\n    })\n  }\n  \n\n  checkJWT() {\n    if(this.authService.isAuthenticated()) {\n      this.router.navigate(['/practice-logs'])\n    }\n  }\n\n}\n","<app-auth-form (submitEmitter)=\"submit($event)\"></app-auth-form>","import { Component, OnInit } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { User } from '../../models/user.interface';\nimport { AuthActions } from '../../state/auth.actions';\n\n@Component({\n  selector: 'app-register',\n  templateUrl: './register.component.html',\n  styleUrls: ['./register.component.scss']\n})\nexport class RegisterComponent implements OnInit {\n  error: string = \"\";\n\n  constructor(private store: Store) {\n\n  }\n\n  ngOnInit(): void {\n    \n  }\n\n  submit(data: User) {\n    this.store.dispatch({type: AuthActions.CREATE_USER, payload: data})\n\n  }\n\n}\n","<app-auth-form title=\"Register\" (submitEmitter)=\"submit($event)\"></app-auth-form>","import { createAction, props } from \"@ngrx/store\";\n\nexport enum AuthActions {\n    LOGIN = '[AUTH] Login',\n    SET_TOKEN = '[AUTH] Set Token',\n    CREATE_USER = '[AUTH] Create User',\n    AUTH_ERROR = '[AUTH] AUTH_ERROR'\n}\n\nexport const setToken = createAction(\n    AuthActions.SET_TOKEN,\n    props<{ token: string }>()\n);\n\nexport const setError = createAction(\n    AuthActions.AUTH_ERROR,\n    props<{ error: any}>()\n)\n\n","import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { map, mergeMap, catchError, tap } from 'rxjs/operators';\nimport { AuthenticateService } from 'src/app/core/services/authenticate.service';\nimport { User } from '../models/user.interface';\nimport { AuthActions } from './auth.actions';\n\n@Injectable()\nexport class AuthEffects {\n \nloginUser$ = createEffect(() => {\n    return this.actions$.pipe(\n        ofType(AuthActions.LOGIN),\n        mergeMap(((data: {type: string, payload: User}) => this.authService.login(data.payload)\n          .pipe(\n            map(data => ({ type: AuthActions.SET_TOKEN, token: data.token })),\n            tap(() =>  this.router.navigate([\"practice-logs\"])),\n            catchError(async (data) => ({ type: AuthActions.AUTH_ERROR, error: data.error }))\n          ))\n        ))\n    }, {dispatch: true}\n  );\n  \n  createUser$ = createEffect(() => {\n    return this.actions$.pipe(\n        ofType(AuthActions.CREATE_USER),\n        mergeMap(((data: {type: string, payload: User}) => this.authService.register(data.payload)\n          .pipe(\n            tap(() =>  this.router.navigate([\"login\"])),\n            catchError(async (data) => ({ type: AuthActions.AUTH_ERROR, error: data.error }))\n          ))\n        ))\n    }, {dispatch: true}\n  );\n  constructor(\n    private actions$: Actions,\n    private authService: AuthenticateService,\n    private router: Router\n  ) {}\n}","import { createReducer, on } from '@ngrx/store';\nimport { setError, setToken } from './auth.actions';\n\nexport interface AuthState {\n    token: string;\n    error: any\n}\n\nexport const initialState: AuthState = {\n    token: \"\",\n    error: null\n}\n\nexport const authReducer = createReducer(\n  initialState,\n  on(setToken, (state, { token }) => { return {...state, token}}),\n  on(setError, (state, { error }) => { return {...state, error}}),\n\n  );\n","import { createSelector, createFeatureSelector } from '@ngrx/store';\nimport { AuthState } from './auth.reducers';\n\nexport const selectAuthState = createFeatureSelector<AuthState>('authState')\n\nexport const selectError = () => createSelector(\n    selectAuthState,\n    (state: AuthState) => state.error\n)","import { NgModule, Optional, SkipSelf } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule\n  ]\n})\nexport class CoreModule { \n  constructor(@Optional() @SkipSelf() core:CoreModule ){\n    if (core) {\n        throw new Error(\"Core module should only be imported to the Root Module\")\n    }\n  }\n}\n\n\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","import deepmerge from 'deepmerge';\n\n// Cannot import from the @ngrx/store package due to a module resolution issue.\n// See Issue #206.\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nconst dateReviver = (_key, value) => {\n    if (typeof value === 'string' && detectDate.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\nconst dummyReviver = (_key, value) => value;\nconst checkIsBrowserEnv = () => {\n    return typeof window !== 'undefined';\n};\nconst validateStateKeys = (keys) => {\n    return keys.map((key) => {\n        let attr = key;\n        if (typeof key === 'object') {\n            attr = Object.keys(key)[0];\n        }\n        if (typeof attr !== 'string') {\n            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n        }\n        return key;\n    });\n};\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n    return keys.reduce((acc, curr) => {\n        let key = curr;\n        let reviver = restoreDates ? dateReviver : dummyReviver;\n        let deserialize;\n        let decrypt;\n        if (typeof key === 'object') {\n            key = Object.keys(key)[0];\n            // use the custom reviver function\n            if (typeof curr[key] === 'function') {\n                reviver = curr[key];\n            }\n            else {\n                // use custom reviver function if available\n                if (curr[key].reviver) {\n                    reviver = curr[key].reviver;\n                }\n                // use custom serialize function if available\n                if (curr[key].deserialize) {\n                    deserialize = curr[key].deserialize;\n                }\n            }\n            // Ensure that encrypt and decrypt functions are both present\n            if (curr[key].encrypt && curr[key].decrypt) {\n                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n                    decrypt = curr[key].decrypt;\n                }\n                else {\n                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n                }\n            }\n            else if (curr[key].encrypt || curr[key].decrypt) {\n                // Let know that one of the encryption functions is not provided\n                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n            }\n        }\n        if (storage !== undefined) {\n            let stateSlice = storage.getItem(storageKeySerializer(key));\n            if (stateSlice) {\n                // Use provided decrypt function\n                if (decrypt) {\n                    stateSlice = decrypt(stateSlice);\n                }\n                const isObjectRegex = new RegExp('{|\\\\[');\n                let raw = stateSlice;\n                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n                    raw = JSON.parse(stateSlice, reviver);\n                }\n                return Object.assign({}, acc, {\n                    [key]: deserialize ? deserialize(raw) : raw,\n                });\n            }\n        }\n        return acc;\n    }, {});\n};\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice, filter) {\n    return filter.reduce((memo, attr) => {\n        if (typeof attr === 'string' || typeof attr === 'number') {\n            const value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];\n            if (value !== undefined) {\n                memo[attr] = value;\n            }\n        }\n        else {\n            for (const key in attr) {\n                if (Object.prototype.hasOwnProperty.call(attr, key)) {\n                    const element = attr[key];\n                    memo[key] = createStateSlice(existingSlice[key], element);\n                }\n            }\n        }\n        return memo;\n    }, {});\n}\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n    if (syncCondition) {\n        try {\n            if (syncCondition(state) !== true) {\n                return;\n            }\n        }\n        catch (e) {\n            // Treat TypeError as do not sync\n            if (e instanceof TypeError) {\n                return;\n            }\n            throw e;\n        }\n    }\n    keys.forEach((key) => {\n        let stateSlice = state[key];\n        let replacer;\n        let space;\n        let encrypt;\n        if (typeof key === 'object') {\n            let name = Object.keys(key)[0];\n            stateSlice = state[name];\n            if (typeof stateSlice !== 'undefined' && key[name]) {\n                // use serialize function if specified.\n                if (key[name].serialize) {\n                    stateSlice = key[name].serialize(stateSlice);\n                }\n                else {\n                    // if serialize function is not specified filter on fields if an array has been provided.\n                    let filter;\n                    if (key[name].reduce) {\n                        filter = key[name];\n                    }\n                    else if (key[name].filter) {\n                        filter = key[name].filter;\n                    }\n                    if (filter) {\n                        stateSlice = createStateSlice(stateSlice, filter);\n                    }\n                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n                    if (key[name].encrypt && key[name].decrypt) {\n                        if (typeof key[name].encrypt === 'function') {\n                            encrypt = key[name].encrypt;\n                        }\n                    }\n                    else if (key[name].encrypt || key[name].decrypt) {\n                        // If one of those is not present, then let know that one is missing\n                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n                    }\n                }\n                /*\n          Replacer and space arguments to pass to JSON.stringify.\n          If these fields don't exist, undefined will be passed.\n        */\n                replacer = key[name].replacer;\n                space = key[name].space;\n            }\n            key = name;\n        }\n        if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n            try {\n                if (encrypt) {\n                    // ensure that a string message is passed\n                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n                }\n                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n            }\n            catch (e) {\n                console.warn('Unable to save state to localStorage:', e);\n            }\n        }\n        else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {\n            try {\n                storage.removeItem(storageKeySerializer(key));\n            }\n            catch (e) {\n                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n            }\n        }\n    });\n};\n// Default merge strategy is a full deep merge.\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n        const options = {\n            arrayMerge: overwriteMerge,\n        };\n        state = deepmerge(state, rehydratedState, options);\n    }\n    return state;\n};\nconst localStorageSync = (config) => (reducer) => {\n    if ((config.storage === undefined && !config.checkStorageAvailability) ||\n        (config.checkStorageAvailability && checkIsBrowserEnv())) {\n        config.storage = localStorage || window.localStorage;\n    }\n    if (config.storageKeySerializer === undefined) {\n        config.storageKeySerializer = (key) => key;\n    }\n    if (config.restoreDates === undefined) {\n        config.restoreDates = true;\n    }\n    // Use default merge reducer.\n    let mergeReducer = config.mergeReducer;\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n        mergeReducer = defaultMergeReducer;\n    }\n    const stateKeys = validateStateKeys(config.keys);\n    const rehydratedState = config.rehydrate\n        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)\n        : undefined;\n    return function (state, action) {\n        let nextState;\n        // If state arrives undefined, we need to let it through the supplied reducer\n        // in order to get a complete state as defined by user\n        if (action.type === INIT_ACTION && !state) {\n            nextState = reducer(state, action);\n        }\n        else {\n            nextState = Object.assign({}, state);\n        }\n        // Merge the store state with the rehydrated state using\n        // either a user-defined reducer or the default.\n        nextState = mergeReducer(nextState, rehydratedState, action);\n        nextState = reducer(nextState, action);\n        if (action.type !== INIT_ACTION) {\n            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n        }\n        return nextState;\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate };\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}"],"names":["createEffect","ofType","map","mergeMap","catchError","tap","AuthActions","AuthEffects","constructor","actions$","authService","router","pipe","LOGIN","data","login","payload","type","SET_TOKEN","token","navigate","AUTH_ERROR","error","dispatch","CREATE_USER","register","i0","factory"],"sourceRoot":"webpack:///"}